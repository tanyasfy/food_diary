{"version":3,"sources":["index.ts"],"names":["printer","ts","createPrinter","newLine","NewLineKind","LineFeed","getJsDocComment","statement","jsDoc","comment","isArrowConst","Boolean","isVariableStatement","declarationList","declarations","initializer","isArrowFunction","getType","isFunctionLike","isTypeAliasDeclaration","isClassDeclaration","isInterfaceDeclaration","type","printNode","EmitHint","Unspecified","getSourceFile","print","param","generateMarkdown","doc","headerDepth","result","Array","fill","join","title","description","params","length","forEach","name","properties","property","members","member","returnType","examples","example","includes","getDocs","filenames","program","createProgram","rootNames","options","checker","getTypeChecker","getParamType","fn","paramType","parameters","find","typeToString","getTypeAtLocation","docs","getSourceFiles","filter","file","isDeclarationFile","map","statements","s","modifiers","e","kind","SyntaxKind","ExportKeyword","jsDocs","getJSDocTags","isJSDocParameterTag","replace","paramName","p","push","getCallSignatures","sig","getReturnTypeOfSignature","memberDescription","tagName","escapedText","reduce","acc","item","getAllDocs","pattern","files","createMatcher","RegExp","generate","matcher","markdown","readme","fs","readFileSync","match","writeFileSync","prettier","format","parser","singleQuote"],"mappings":"kpBAAA,8DACA,8CACA,0DACA,2DAEA,GAAMA,CAAAA,OAAO,CAAGC,uBAAGC,aAAH,CAAiB,CAAEC,OAAO,CAAEF,uBAAGG,WAAH,CAAeC,QAA1B,CAAjB,CAAhB,CA+BA,QAASC,CAAAA,eAAT,CAAyBC,SAAzB,CAA6C,CAC3C,MAAQA,CAAAA,SAAD,CAAmBC,KAAnB,EAA6BD,SAAD,CAAmBC,KAAnB,CAAyB,CAAzB,CAA5B,CACFD,SAAD,CAAmBC,KAAnB,CAAyB,CAAzB,EAA4BC,OADzB,CAEH,EACL,CAGD,QAASC,CAAAA,YAAT,CAAsBH,SAAtB,CAA6E,CAC3E,MAAOI,CAAAA,OAAO,CACZV,uBAAGW,mBAAH,CAAuBL,SAAvB,GACEA,SAAS,CAACM,eAAV,CAA0BC,YAA1B,CAAuC,CAAvC,EAA0CC,WAD5C,EAEEd,uBAAGe,eAAH,CAAmBT,SAAS,CAACM,eAAV,CAA0BC,YAA1B,CAAuC,CAAvC,EAA0CC,WAA7D,CAHU,CAKf,CAGD,QAASE,CAAAA,OAAT,CAAiBV,SAAjB,CAAqC,CACnC,GAAIG,YAAY,CAACH,SAAD,CAAZ,EAA2BN,uBAAGiB,cAAH,CAAkBX,SAAlB,CAA/B,CAA6D,CAC3D,MAAO,UACR,CAED,GAAIN,uBAAGkB,sBAAH,CAA0BZ,SAA1B,CAAJ,CAA0C,CACxC,MAAO,MACR,CAED,GAAIN,uBAAGmB,kBAAH,CAAsBb,SAAtB,CAAJ,CAAsC,CACpC,MAAO,OACR,CAED,GAAIN,uBAAGoB,sBAAH,CAA0Bd,SAA1B,CAAJ,CAA0C,CACxC,MAAO,WACR,CAED,GAAIN,uBAAGW,mBAAH,CAAuBL,SAAvB,CAAJ,CAAuC,CACrC,GAAIA,SAAS,CAACM,eAAV,CAA0BC,YAA1B,CAAuC,CAAvC,EAA0CQ,IAA9C,CAAoD,CAClD,0BAAoBtB,OAAO,CAACuB,SAAR,CAClBtB,uBAAGuB,QAAH,CAAYC,WADM,CAElBlB,SAAS,CAACM,eAAV,CAA0BC,YAA1B,CAAuC,CAAvC,EAA0CQ,IAFxB,CAGlBf,SAAS,CAACmB,aAAV,EAHkB,CAApB,CAKD,CAED,MAAO,UACR,CACF,CAGD,QAASC,CAAAA,KAAT,CAAeC,KAAf,CAAuC,CACrC,MAAO5B,CAAAA,OAAO,CAACuB,SAAR,CACLtB,uBAAGuB,QAAH,CAAYC,WADP,CAELG,KAFK,CAGLA,KAAK,CAACF,aAAN,EAHK,CAKR,CAOM,QAASG,CAAAA,gBAAT,CAA0BC,GAA1B,CAAoE,IAAjBC,CAAAA,WAAiB,2DAAH,CAAG,CACzE,GAAIC,CAAAA,MAAM,WAAMC,KAAK,CAACF,WAAD,CAAL,CACbG,IADa,CACR,GADQ,EAEbC,IAFa,CAER,EAFQ,CAAN,cAEOL,GAAG,CAACM,KAFX,eAEuBN,GAAG,CAACR,IAF3B,SAAV,CAIA,GAAIQ,GAAG,CAACO,WAAR,CAAqB,CACnBL,MAAM,YAAOF,GAAG,CAACO,WAAX,QACP,CAED,GAAIP,GAAG,CAACQ,MAAJ,EAAcR,GAAG,CAACQ,MAAJ,CAAWC,MAAX,CAAoB,CAAtC,CAAyC,CACvCP,MAAM,EAAI,qBAAV,CAEAF,GAAG,CAACQ,MAAJ,CAAWE,OAAX,CAAmB,SAAAZ,KAAK,CAAI,CAC1BI,MAAM,cAASJ,KAAK,CAACa,IAAf,aAAuBb,KAAK,CAACN,IAAN,aAAmBM,KAAK,CAACN,IAAzB,QAAsC,EAA7D,SACJM,KAAK,CAACS,WAAN,aAAyBT,KAAK,CAACS,WAA/B,EAA+C,EAD3C,MAGP,CAJD,EAMAL,MAAM,EAAI,IACX,CAED,GAAIF,GAAG,CAACY,UAAJ,EAAkBZ,GAAG,CAACY,UAAJ,CAAeH,MAAf,CAAwB,CAA9C,CAAiD,CAC/CP,MAAM,EAAI,qBAAV,CAEAF,GAAG,CAACY,UAAJ,CAAeF,OAAf,CAAuB,SAAAG,QAAQ,CAAI,CACjCX,MAAM,cAASW,QAAT,MACP,CAFD,EAIAX,MAAM,EAAI,IACX,CAED,GAAIF,GAAG,CAACc,OAAJ,EAAed,GAAG,CAACc,OAAJ,CAAYL,MAAZ,CAAqB,CAAxC,CAA2C,CACzCP,MAAM,EAAI,kBAAV,CAEAF,GAAG,CAACc,OAAJ,CAAYJ,OAAZ,CAAoB,SAAAK,MAAM,CAAI,CAC5Bb,MAAM,cAASa,MAAT,MACP,CAFD,EAIAb,MAAM,EAAI,IACX,CAED,GAAIF,GAAG,CAACgB,UAAR,CAAoB,CAClBd,MAAM,yBAAoBF,GAAG,CAACgB,UAAxB,QACP,CAED,GAAIhB,GAAG,CAACiB,QAAJ,EAAgBjB,GAAG,CAACiB,QAAJ,CAAaR,MAAb,CAAsB,CAA1C,CAA6C,CAC3CT,GAAG,CAACiB,QAAJ,CAAaP,OAAb,CAAqB,SAAAQ,OAAO,CAAI,CAC9BhB,MAAM,YACJgB,OAAO,CAACC,QAAR,CAAiB,KAAjB,EAA0BD,OAA1B,mBAAkDA,OAAlD,WADI,MAGP,CAJD,EAMAhB,MAAM,EAAI,IACX,CAED,MAAOA,CAAAA,MACR,CAGD,QAASkB,CAAAA,OAAT,CAAiBC,SAAjB,CAA4D,CAC1D,GAAMC,CAAAA,OAAO,CAAGnD,uBAAGoD,aAAH,CAAiB,CAAEC,SAAS,CAAEH,SAAb,CAAwBI,OAAO,CAAE,EAAjC,CAAjB,CAAhB,CACA,GAAMC,CAAAA,OAAO,CAAGJ,OAAO,CAACK,cAAR,EAAhB,CAGA,QAASC,CAAAA,YAAT,CAAsB5B,GAAtB,CAAiDvB,SAAjD,CAAqE,CACnE,GAAMkC,CAAAA,IAAI,CAAGd,KAAK,CAACG,GAAG,CAACW,IAAL,CAAlB,CACA,GAAMkB,CAAAA,EAAE,CAAGjD,YAAY,CAACH,SAAD,CAAZ,CACPA,SAAS,CAACM,eAAV,CAA0BC,YAA1B,CAAuC,CAAvC,EAA0CC,WADnC,CAEPR,SAFJ,CAIA,GAAI,CAACoD,EAAD,EAAO,CAAC1D,uBAAGiB,cAAH,CAAkByC,EAAlB,CAAZ,CAAmC,CACjC,MAAO,EACR,CAED,GAAMC,CAAAA,SAAS,CAAGD,EAAE,CAACE,UAAH,CAAcC,IAAd,CAAmB,SAAAlC,KAAK,QAAID,CAAAA,KAAK,CAACC,KAAK,CAACa,IAAP,CAAL,GAAsBA,IAA1B,CAAxB,CAAlB,CAEA,MAAOmB,CAAAA,SAAS,CACZJ,OAAO,CAACO,YAAR,CAAqBP,OAAO,CAACQ,iBAAR,CAA0BJ,SAA1B,CAArB,CADY,CAEZ,EACL,CAED,GAAMK,CAAAA,IAAI,CAAGb,OAAO,CACjBc,cADU,GAEVC,MAFU,CAEH,SAAAC,IAAI,QAAI,CAACA,IAAI,CAACC,iBAAV,CAFD,EAGVC,GAHU,CAGN,SAAAF,IAAI,QACPA,CAAAA,IAAI,CAACG,UAAL,CACGJ,MADH,CACU,SAACK,CAAD,QAMN7D,CAAAA,OAAO,CACL6D,CAAC,CAACC,SAAF,EAEED,CAAC,CAACC,SAAF,CAAYX,IAAZ,CAAiB,SAAAY,CAAC,QAAIA,CAAAA,CAAC,CAACC,IAAF,GAAW1E,uBAAG2E,UAAH,CAAcC,aAA7B,CAAlB,CAFF,GAGG5E,uBAAGW,mBAAH,CAAuB4D,CAAvB,GACCvE,uBAAGiB,cAAH,CAAkBsD,CAAlB,CADD,EAECvE,uBAAGkB,sBAAH,CAA0BqD,CAA1B,CAFD,EAGCvE,uBAAGmB,kBAAH,CAAsBoD,CAAtB,CAHD,EAICvE,uBAAGoB,sBAAH,CAA0BmD,CAA1B,CAPJ,CADK,CAND,CADV,EAkBGF,GAlBH,CAkBO,SAAA/D,SAAS,CAAI,CAChB,GAAM6B,CAAAA,KAAK,CAAGnC,uBAAGW,mBAAH,CAAuBL,SAAvB,EACVoB,KAAK,CAACpB,SAAS,CAACM,eAAV,CAA0BC,YAA1B,CAAuC,CAAvC,EAA0C2B,IAA3C,CADK,CAETlC,SAAS,CAACkC,IAAV,EAAkBd,KAAK,CAACpB,SAAS,CAACkC,IAAX,CAAxB,EAA6C,EAFjD,CAIA,GAAMJ,CAAAA,WAAW,CAAG/B,eAAe,CAACC,SAAD,CAAnC,CACA,GAAMuE,CAAAA,MAAM,CAAG7E,uBAAG8E,YAAH,CAAgBxE,SAAhB,CAAf,CAEA,GAAIuC,CAAAA,UAAJ,CAEA,GAAMR,CAAAA,MAAe,CAAGwC,MAAM,CAC3BX,MADqB,CACdlE,uBAAG+E,mBADW,EAErBV,GAFqB,CAEjB,SAACxC,GAAD,QAAgC,CACnCW,IAAI,CAAEd,KAAK,CAACG,GAAG,CAACW,IAAL,CADwB,CAEnCJ,WAAW,CAAEP,GAAG,CAACrB,OAAJ,CAAcqB,GAAG,CAACrB,OAAJ,CAAYwE,OAAZ,CAAoB,KAApB,CAA2B,EAA3B,CAAd,CAA+C,EAFzB,CAGnC3D,IAAI,CAAEoC,YAAY,CAAC5B,GAAD,CAAMvB,SAAN,CAHiB,CAAhC,CAFiB,CAAxB,CAQA,GAAIN,uBAAGiB,cAAH,CAAkBX,SAAlB,CAAJ,CAAkC,CAChCA,SAAS,CAACsD,UAAV,CAAqBrB,OAArB,CAA6B,SAAAZ,KAAK,CAAI,CACpC,GAAMsD,CAAAA,SAAS,CAAGvD,KAAK,CAACC,KAAK,CAACa,IAAP,CAAvB,CAEA,GAAIH,MAAM,CAACwB,IAAP,CAAY,SAAAqB,CAAC,QAAIA,CAAAA,CAAC,CAAC1C,IAAF,GAAWyC,SAAf,CAAb,CAAJ,CAA4C,CAC1C,MACD,CAED5C,MAAM,CAAC8C,IAAP,CAAY,CACV3C,IAAI,CAAEyC,SADI,CAEV5D,IAAI,CAAEkC,OAAO,CAACO,YAAR,CAAqBP,OAAO,CAACQ,iBAAR,CAA0BpC,KAA1B,CAArB,CAFI,CAAZ,CAID,CAXD,EAaA,GAAMN,CAAAA,IAAI,CAAGkC,OAAO,CAACQ,iBAAR,CAA0BzD,SAA1B,CAAb,CAdgC,0BAgBjBe,IAAI,CAChB+D,iBADY,GAEZf,GAFY,CAER,SAAAgB,GAAG,QACN9B,CAAAA,OAAO,CAACO,YAAR,CAAqBP,OAAO,CAAC+B,wBAAR,CAAiCD,GAAjC,CAArB,CADM,CAFK,CAhBiB,oFAgB/BxC,UAhB+B,0BAqBjC,CAED,GAAIF,CAAAA,OAAiB,CAAG,EAAxB,CAEA,GAAI3C,uBAAGoB,sBAAH,CAA0Bd,SAA1B,CAAJ,CAA0C,CACxCqC,OAAO,CAAGrC,SAAS,CAACqC,OAAV,CAAkB0B,GAAlB,CAAsB,SAAAzB,MAAM,CAAI,CACxC,GAAM2C,CAAAA,iBAAiB,CAAGlF,eAAe,CAACuC,MAAD,CAAzC,CAGA,gBAAUlB,KAAK,CAACkB,MAAM,CAACJ,IAAR,CAAL,CAAoBwC,OAApB,CACR,sBADQ,CAER,IAFQ,CAAV,eAGQzB,OAAO,CAACO,YAAR,CACNP,OAAO,CAACQ,iBAAR,CAA0BnB,MAA1B,CADM,CAHR,cAKO2C,iBAAiB,cAASA,iBAAT,EAA+B,EALvD,CAMD,CAVS,CAWX,CAED,GAAMzC,CAAAA,QAAQ,CAAG+B,MAAM,CACpBX,MADc,CACP,SAAArC,GAAG,QAAIA,CAAAA,GAAG,CAAC2D,OAAJ,CAAYC,WAAZ,GAA4B,SAAhC,CADI,EAEdpB,GAFc,CAEV,SAAAxC,GAAG,QAAIA,CAAAA,GAAG,CAACrB,OAAR,CAFO,EAGd0D,MAHc,CAGP,SAACrC,GAAD,QAAwBnB,CAAAA,OAAO,CAACmB,GAAD,CAA/B,CAHO,CAAjB,CAKA,GAAMY,CAAAA,UAAU,CAAGoC,MAAM,CACtBX,MADgB,CACT,SAAArC,GAAG,QAAIA,CAAAA,GAAG,CAAC2D,OAAJ,CAAYC,WAAZ,GAA4B,UAAhC,CADM,EAEhBpB,GAFgB,CAEZ,SAAAxC,GAAG,QAAIA,CAAAA,GAAG,CAACrB,OAAR,CAFS,EAGhB0D,MAHgB,CAGT,SAACrC,GAAD,QAAwBnB,CAAAA,OAAO,CAACmB,GAAD,CAA/B,CAHS,CAAnB,CAKA,MAAO,CACLM,KAAK,CAALA,KADK,CAELC,WAAW,CAAXA,WAFK,CAGLU,QAAQ,CAARA,QAHK,CAILT,MAAM,CAANA,MAJK,CAKLI,UAAU,CAAVA,UALK,CAMLI,UAAU,CAAVA,UANK,CAOLF,OAAO,CAAPA,OAPK,CAQLtB,IAAI,CAAEL,OAAO,CAACV,SAAD,CARR,CAUR,CA/FH,CADO,CAHE,CAAb,CAsGA,MAAO0D,CAAAA,IAAI,CAAC0B,MAAL,CAAY,SAACC,GAAD,CAAMC,IAAN,qDAAmBD,GAAnB,qCAA2BC,IAA3B,GAAZ,CAA8C,EAA9C,CACR,C,QAOqBC,CAAAA,U,8IAAf,yKACLC,OADK,+CACwB,CAAC,qBAAD,CAAwB,eAAxB,CADxB,uBAGe,yBAAKA,OAAL,CAHf,QAGCC,KAHD,+CAIE9C,OAAO,CAAC8C,KAAD,CAJT,uD,4CAaA,QAASC,CAAAA,aAAT,CAAuBxD,IAAvB,CAAqC,CAC1C,MAAO,IAAIyD,CAAAA,MAAJ,iBACIzD,IADJ,gDAC+CA,IAD/C,cAGR,C,QAqB6B0D,CAAAA,Q,wIAAf,gQAAwB5C,OAAxB,kDAAmD,EAAnD,kBAKTA,OALS,CAEX6C,OAFW,CAEXA,OAFW,2BAEDH,aAAa,CAAC,uBAAD,CAFZ,kBAGXF,OAHW,CAKTxC,OALS,CAGXwC,OAHW,sBAKTxC,OALS,CAIXxB,WAJW,CAIXA,WAJW,+BAIG,CAJH,6CAMM+D,CAAAA,UAAU,CAACC,OAAD,CANhB,QAMP9B,IANO,gBAOPoC,QAPO,CAOIpC,IAAI,CAACK,GAAL,CAAS,SAAAxC,GAAG,QAAID,CAAAA,gBAAgB,CAACC,GAAD,CAAMC,WAAN,CAApB,CAAZ,CAPJ,CASTuE,MATS,CASAC,eAAGC,YAAH,CAAgB,aAAhB,CAA+B,MAA/B,CATA,CAWb,GAAIF,MAAM,CAACG,KAAP,CAAaL,OAAb,CAAJ,CAA2B,CACzBE,MAAM,CAAGA,MAAM,CAACrB,OAAP,CAAemB,OAAf,aAA6BC,QAAQ,CAAClE,IAAT,CAAc,IAAd,CAA7B,OAAT,CAEAoE,eAAGG,aAAH,CACE,aADF,CAEEC,qBAASC,MAAT,CAAgBN,MAAhB,CAAwB,CAAEO,MAAM,CAAE,UAAV,CAAsBC,WAAW,CAAE,IAAnC,CAAxB,CAFF,CAID,CAlBY,uD","sourcesContent":["import ts from 'typescript';\nimport fs from 'fs';\nimport prettier from 'prettier';\nimport glob from 'fast-glob';\n\nconst printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });\n\ninterface Param {\n  /** The name of the param */\n  name: string;\n  /** A description of the param */\n  description?: string;\n  /** The type of the param */\n  type: string;\n}\n\ninterface TypeScriptDocument {\n  /** The title of the exported thing */\n  title: string;\n  /** The description of the exported thing */\n  description?: string;\n  /** Example of usage */\n  examples?: string[];\n  /** Params if applicable */\n  params?: Param[];\n  /** Properties if applicable */\n  properties?: string[];\n  /** Interface members if applicable */\n  members?: string[];\n  /** The type of the exported member */\n  type?: string;\n  /** If a function the type of the return */\n  returnType?: string;\n}\n\n/** Return the jsDoc comment if there is one */\nfunction getJsDocComment(statement: ts.Node) {\n  return (statement as any).jsDoc && (statement as any).jsDoc[0]\n    ? (statement as any).jsDoc[0].comment\n    : '';\n}\n\n/** Determine if a constant is a function decl */\nfunction isArrowConst(statement: ts.Node): statement is ts.VariableStatement {\n  return Boolean(\n    ts.isVariableStatement(statement) &&\n      statement.declarationList.declarations[0].initializer &&\n      ts.isArrowFunction(statement.declarationList.declarations[0].initializer)\n  );\n}\n\n/** Get the type of a statement */\nfunction getType(statement: ts.Node) {\n  if (isArrowConst(statement) || ts.isFunctionLike(statement)) {\n    return 'function';\n  }\n\n  if (ts.isTypeAliasDeclaration(statement)) {\n    return 'type';\n  }\n\n  if (ts.isClassDeclaration(statement)) {\n    return 'class';\n  }\n\n  if (ts.isInterfaceDeclaration(statement)) {\n    return 'interface';\n  }\n\n  if (ts.isVariableStatement(statement)) {\n    if (statement.declarationList.declarations[0].type) {\n      return `variable: ${printer.printNode(\n        ts.EmitHint.Unspecified,\n        statement.declarationList.declarations[0].type,\n        statement.getSourceFile()\n      )}`;\n    }\n\n    return 'variable';\n  }\n}\n\n/** Get the type of a param */\nfunction print(param: ts.Node): string {\n  return printer.printNode(\n    ts.EmitHint.Unspecified,\n    param,\n    param.getSourceFile()\n  );\n}\n\n/**\n * Generate the markdown docs a doc returned from `getAllDocs`\n *\n * @param doc - The TypeScript document to generate types for\n */\nexport function generateMarkdown(doc: TypeScriptDocument, headerDepth = 3) {\n  let result = `${Array(headerDepth)\n    .fill('#')\n    .join('')} \\`${doc.title}\\` (${doc.type})\\n\\n`;\n\n  if (doc.description) {\n    result += `${doc.description}\\n\\n`;\n  }\n\n  if (doc.params && doc.params.length > 0) {\n    result += '**Parameters:**\\n\\n';\n\n    doc.params.forEach(param => {\n      result += `- ${param.name} ${param.type ? `(\\`${param.type}\\`) ` : ''}${\n        param.description ? `- ${param.description}` : ''\n      }\\n`;\n    });\n\n    result += '\\n';\n  }\n\n  if (doc.properties && doc.properties.length > 0) {\n    result += '**Properties:**\\n\\n';\n\n    doc.properties.forEach(property => {\n      result += `- ${property}\\n`;\n    });\n\n    result += '\\n';\n  }\n\n  if (doc.members && doc.members.length > 0) {\n    result += '**Members:**\\n\\n';\n\n    doc.members.forEach(member => {\n      result += `- ${member}\\n`;\n    });\n\n    result += '\\n';\n  }\n\n  if (doc.returnType) {\n    result += `**returns:** ${doc.returnType}\\n\\n`;\n  }\n\n  if (doc.examples && doc.examples.length > 0) {\n    doc.examples.forEach(example => {\n      result += `${\n        example.includes('```') ? example : `\\`\\`\\`tsx\\n${example}\\n\\`\\`\\`\\n`\n      }\\n`;\n    });\n\n    result += '\\n';\n  }\n\n  return result;\n}\n\n/** Get the docs for all functions and interfaces exported from the file */\nfunction getDocs(filenames: string[]): TypeScriptDocument[] {\n  const program = ts.createProgram({ rootNames: filenames, options: {} });\n  const checker = program.getTypeChecker();\n\n  /** Match jsdoc name to function type decl */\n  function getParamType(doc: ts.JSDocParameterTag, statement: ts.Node) {\n    const name = print(doc.name);\n    const fn = isArrowConst(statement)\n      ? statement.declarationList.declarations[0].initializer\n      : statement;\n\n    if (!fn || !ts.isFunctionLike(fn)) {\n      return '';\n    }\n\n    const paramType = fn.parameters.find(param => print(param.name) === name);\n\n    return paramType\n      ? checker.typeToString(checker.getTypeAtLocation(paramType))\n      : '';\n  }\n\n  const docs = program\n    .getSourceFiles()\n    .filter(file => !file.isDeclarationFile)\n    .map(file =>\n      file.statements\n        .filter((s): s is\n          | ts.VariableStatement\n          | ts.FunctionDeclaration\n          | ts.TypeAliasDeclaration\n          | ts.ClassDeclaration\n          | ts.InterfaceDeclaration =>\n          Boolean(\n            s.modifiers &&\n              // This determines if it is exported\n              s.modifiers.find(e => e.kind === ts.SyntaxKind.ExportKeyword) &&\n              (ts.isVariableStatement(s) ||\n                ts.isFunctionLike(s) ||\n                ts.isTypeAliasDeclaration(s) ||\n                ts.isClassDeclaration(s) ||\n                ts.isInterfaceDeclaration(s))\n          )\n        )\n        .map(statement => {\n          const title = ts.isVariableStatement(statement)\n            ? print(statement.declarationList.declarations[0].name)\n            : (statement.name && print(statement.name)) || '';\n\n          const description = getJsDocComment(statement);\n          const jsDocs = ts.getJSDocTags(statement);\n\n          let returnType: string | undefined;\n\n          const params: Param[] = jsDocs\n            .filter(ts.isJSDocParameterTag)\n            .map((doc: ts.JSDocParameterTag) => ({\n              name: print(doc.name),\n              description: doc.comment ? doc.comment.replace(/^- /, '') : '',\n              type: getParamType(doc, statement)\n            }));\n\n          if (ts.isFunctionLike(statement)) {\n            statement.parameters.forEach(param => {\n              const paramName = print(param.name);\n\n              if (params.find(p => p.name === paramName)) {\n                return;\n              }\n\n              params.push({\n                name: paramName,\n                type: checker.typeToString(checker.getTypeAtLocation(param))\n              });\n            });\n\n            const type = checker.getTypeAtLocation(statement);\n\n            [returnType] = type\n              .getCallSignatures()\n              .map(sig =>\n                checker.typeToString(checker.getReturnTypeOfSignature(sig))\n              );\n          }\n\n          let members: string[] = [];\n\n          if (ts.isInterfaceDeclaration(statement)) {\n            members = statement.members.map(member => {\n              const memberDescription = getJsDocComment(member);\n\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              return `${print(member.name!).replace(\n                /\\/\\*\\*.*\\*\\/\\s+(\\S+)/,\n                '$1'\n              )} (\\`${checker.typeToString(\n                checker.getTypeAtLocation(member)\n              )}\\`)${memberDescription ? ` - ${memberDescription}` : ''}`;\n            });\n          }\n\n          const examples = jsDocs\n            .filter(doc => doc.tagName.escapedText === 'example')\n            .map(doc => doc.comment)\n            .filter((doc): doc is string => Boolean(doc));\n\n          const properties = jsDocs\n            .filter(doc => doc.tagName.escapedText === 'property')\n            .map(doc => doc.comment)\n            .filter((doc): doc is string => Boolean(doc));\n\n          return {\n            title,\n            description,\n            examples,\n            params,\n            properties,\n            returnType,\n            members,\n            type: getType(statement)\n          };\n        })\n    );\n\n  return docs.reduce((acc, item) => [...acc, ...item], []);\n}\n\n/**\n * Get the docs for all some files in the project.\n *\n * @param pattern - A glob pattern or patterns to match files from\n */\nexport async function getAllDocs(\n  pattern: string | string[] = ['./src/**/*.(ts|tsx)', '!**/__tests__']\n) {\n  const files = await glob(pattern);\n  return getDocs(files);\n}\n\n/**\n * Create a markdown comment matcher. This matches the section where\n * we will insert docs. Use this to create a custom section.\n *\n * @param name - The name to use in the markdown comment\n */\nexport function createMatcher(name: string) {\n  return new RegExp(\n    `(<!-- ${name} START -->\\\\s*)([\\\\S\\\\s]*)(\\\\s*<!-- ${name} END -->)`\n  );\n}\n\nexport interface GenerateOptions {\n  /** A regex to match the part of the readme  */\n  matcher?: RegExp;\n  /** A glob pattern or patterns to match files from */\n  pattern?: string | string[];\n  /** How deep the markdown headers should be */\n  headerDepth?: number;\n}\n\n/**\n * Generate all the docs and put it in the README.\n *\n * @param options - Options for generating the docs\n *\n * @example\n * import generate, { createMatcher } from 'ts-readme';\n *\n * generate({ matcher: createMatcher('TS-README-GENERATED') })\n */\nexport default async function generate(options: GenerateOptions = {}) {\n  const {\n    matcher = createMatcher('INSERT GENERATED DOCS'),\n    pattern,\n    headerDepth = 3\n  } = options;\n  const docs = await getAllDocs(pattern);\n  const markdown = docs.map(doc => generateMarkdown(doc, headerDepth));\n\n  let readme = fs.readFileSync('./README.md', 'utf8');\n\n  if (readme.match(matcher)) {\n    readme = readme.replace(matcher, `$1${markdown.join('\\n')}$3`);\n\n    fs.writeFileSync(\n      './README.md',\n      prettier.format(readme, { parser: 'markdown', singleQuote: true })\n    );\n  }\n}\n"]}
